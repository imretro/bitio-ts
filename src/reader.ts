import type { Bit } from './types';
import BitIterator from './bit-iterator';

/**
 * Reads bits from a Uint* typed array.
 *
 * The number of bits per number depends on the size of the Uint. For example,
 * a `Uint16Array` results in 16 bits being read for each number in the array.
 *
 * Bits are read from *largest* to *smallest.* For example, with
 * `new Uint16Array([1, 1 << 15])`, `1` is the last bit read from the first
 * element, and the first bit read from the second element. This order is
 * left-to-right, assuming big-endian numbers.
 *
 * This acts as an iterator, meaning it is not possible to reverse a read.
 */
export default class Reader extends BitIterator {
  constructor(src: Uint8Array | Uint16Array | Uint32Array);

  /**
   * Reads a single [[Bit | bit]].
   *
   * @returns A single bit, or null if there are no more bits to read.
   */
  public readBit(): Bit | null {
    if (this.index >= this.bytes.length) {
      return null;
    }

    const bit = this.bytes[this.index] >> (this.bitsPerElement - this.offset);

    this.nextOffset();

    return (bit & 1) === 0 ? 0 : 1;
  }

  /**
   * Collects multiple bits into a number.
   *
   * For example, if 16 bits were collected from
   * `new Uint8Array([0xAB, 0xCD])`, the resulting number is `0xABCD`.
   *
   * If `n` exceeds the number of available bits, an error will be thrown.
   *
   * See also [[`readBitsSafe`]].
   *
   * @param n The number of bits to read.
   *
   * @returns The bits collected into a `number`.
   */
  public readBits(n: number): number {
    if (n > this.remaining) {
      throw new RangeError('n exceeds the number of remaining bits');
    }
    let result = 0;

    for (let i = 1; i <= n; i += 1) {
      const bit = this.readBit() as Bit;
      result |= bit << (n - i);
    }
    return result;
  }

  /**
   * Collects `n` bits into an array.
   *
   * Unlike [[`readBits`]] does not throw an error if there are not enough
   * bits to read, but uses `null` for any extra index that could not have a
   * bit read to it.
   *
   * See also [[`collectBits`]].
   *
   * @param n The number of bits to try to read.
   *
   * @returns An array of bits, with `null` for unreadable bits.
   */
  public readBitsSafe(n: number): Array<Bit | null> {
    const bits = new Array<Bit | null>(n);
    for (let i = 0; i < bits.length; i += 1) {
      bits[i] = this.readBit();
    }
    return bits;
  }

  /**
   * Collects an array of `n` bits into a number.
   *
   * Use with [[`readBitsSafe`]] and `.filter` to safely collect bits into a
   * number. The most significant bit will be on the left, so `[1, 1, 0, 1]`
   * would equal the numeric literal `0b1101`.
   *
   * Will return `0` if there are no bits to read.
   *
   * @returns A number generated by collecting bits.
   */
  public static collectBits(bits: Bit[]): number {
    return bits.reduce((collected: number, bit) => ((collected << 1) | bit), 0);
  }

  /**
   * Reads a single byte.
   *
   * Returns `null` if there is no byte to read.
   *
   * Will throw a `RangeError` if a partial byte is unread. For example, if
   * 4 bits have been read, the other 4 must also be read before `readByte` is
   * called.
   *
   * @returns An 8-bit number.
   */
  public readByte(): number | null {
    if (this.remaining % 8 !== 0) {
      throw new RangeError('Cannot read a partial byte as a full byte');
    }
    // NOTE Only bitshift every 8 bits
    const { byteCount, byteIndex } = this;
    if (byteIndex >= byteCount) {
      return null;
    }
    const shift = ((this.bytesPerElement - 1) - (byteIndex % this.bytesPerElement)) * 8;
    const b = this.bytes[this.index] >> shift;
    this.nextOffset(8);
    // NOTE Reduce to a single byte
    return b & 0xFF;
  }

  /**
   * Reads `n` bytes.
   *
   * Bytes that do not exist will be `null`.
   *
   * Throws on partial bytes (see [[`readByte`]]).
   *
   * @returns An array of 8-bit numbers.
   */
  public readBytes(n: number): Array<number | null> {
    const bytes = new Array<number | null>(n);
    for (let i = 0; i < bytes.length; i += 1) {
      bytes[i] = this.readByte();
    }
    return bytes;
  }

  /**
   * Reads all remaining bits to a number. Equivalent to
   * `reader.readBits(reader.remaining)`.
   *
   * @returns The remaining bits.
   */
  public readAll(): number {
    return this.readBits(this.remaining);
  }

  /**
   * Iterates over [[Bit | bits]].
   *
   * When done, returns the number of bits read.
   *
   * @returns Number of bits read.
   */
  public* [Symbol.iterator](): Generator<Bit, number, void> {
    let count = 0;
    while (true) {
      const bit = this.readBit();
      if (bit == null) {
        return count;
      }
      yield bit;
      count += 1;
    }
  }
}
